<html>
  <head style="background: lightseagreen;">
    header
  </head>
  <body>
      <div id="block">
        <button id="debounce" onClick="runProgram(1)">5</button>
        <button id="debounce" onClick="runProgram(2)">10</button>
        <button id="debounce" onClick="runProgram(3)">22</button>
        <button id="debounce" onClick="runProgram(4)">10</button>
  </body>
  <script>
  function runProgram(val) {
      if (val === 1) {
        let arr = 'babad';
        const res1 = five(arr);
        console.log(res1);
      }
      if (val === 2) {
        let s = "aa", p = "a"
        const res1 = ten(s,p);
        console.log(res1);
      }
      if (val === 3) {
        let arr = ["((()))","(()())","(())()","()(())","()()()"];
        const res1 = f22(arr);
        console.log(res1);
      }
      if (val === 4) {
        let arr = [-1, 0, 1, 2, -1, -4];
        const res1 = fifteen(arr);
        console.log(res1);
      }
  }
  function five(s){
    // 这是一个中心扩展法
    if (s.length <= 0) {//边界条件
        return s;
    }
    let start = 0
    let maxLength = 1
    function h(left,right){
     //当s[left]，和 s[right]想等时，不断向外扩展回文字符串的长度
     while(s[left] === s[right] && left >=0 && right <s.length){
      if (right - left + 1 > maxLength) {
                maxLength = right - left + 1;//更新最大回文子串的长度
                start = left;//更新start的位置
                console.log('更新了  ', maxLength)
                console.log('更新了  ', start)
            }
            left--;
            right++;
     }
  }
    for(let i=0;i<s.length;i++){
      h(i - 1, i + 1);//回文子串是奇数
      h(i, i + 1);//回文子串是偶数
    }
    return s.substring(start, start + maxLength)
  }
  function five2(s){
  // 这是一个动态规划法
  // 但是感觉没有get到这个动态规划的意义是什么
  let n = s.length
  let res = ''
  let dp = Array.from(new Array(n), () => new Array(n).fill(false));//初始化数组 
  for(let i=n-1;i>=0;i--){
    for(let j = i;j < n;j++){
      console.log('输出怎么的  ',i,'-',j)
       //dp[i][j]表示子串i～j是否是回文子串
          //回文子串必须满足s[i]，s[j]相等。并且向外扩展一个字符也相等，即dp[i+1][j-1]也是回文子串
          //j - i < 2表示子串小于等于1也是回文串
          dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i+1][j-1]);
            if(dp[i][j] && j - i +1 > res.length){//当前回文子串比之前的大，更新最大长度
                res = s.substring(i,j+1);
            }
    }
  }
  return res
  }
  function ten(s,p){
  // 动态规划 dp[i][j]表示s的前i个能否与p的前j个匹配，关于这个题干的一点，*是可以用来匹配0位的
  if (s == null || p == null) return false;
  const sLen = s.length, pLen = p.length;
  const dp = new Array(sLen + 1);//因为位置是从0开始的，第0个位置是空字符串 所以初始化长度是sLen + 1
  for (let i = 0; i < dp.length; i++) {
    dp[i] = new Array(pLen + 1).fill(false);
  }
  // base case s和p第0个位置是匹配的
  dp[0][0] = true;
  for (let j = 1; j < pLen + 1; j++) {//初始化dp的第一列，此时s的位置是0
        //情况1:如果p的第j-1个位置是*，则j的状态等于j-2的状态
        if (p[j - 1] == "*") dp[0][j] = dp[0][j - 2];
  }
    // 迭代
    for (let i = 1; i < sLen + 1; i++) {
        for (let j = 1; j < pLen + 1; j++) {
            if (s[i - 1] == p[j - 1] || p[j - 1] == ".") {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] == "*") {
                if (s[i - 1] == p[j - 2] || p[j - 2] == ".") {
                    dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i][j - 2];
                }
            }
        }
    }
    return dp[sLen][pLen];
  }
  function f22(n){

  }
  function fifteen(arr){

  }
  </script>
</html>
