<html>
  <head style="background: lightseagreen">
    header
  </head>
  <body>
    <footer></footer>
  </body>
  <script>
    // 手写new
    // 创建一个继承自func.prototype的新对象
    //截取new1函数第二个以及第二个之后的参数,在newObj作用域内执行改造函数func
    //如果传入参数中的构造函数执行后的returnObj是“对象”类型(比如new1(Object)),那么这个对象会取代newObj作为返回的对象
    function new1(func) {
      var newObj = Object.create(func.prototype);
      var returnObj = func.apply(
        newObj,
        Array.prototype.slice.call(arguments, 1)
      );
      if (
        (typeof returnObj === "object" || typeof returnObj === "function") &&
        ret !== null
      ) {
        return returnObj;
      }
      return newObj;
    }
    // 新生成一个对象,且新对象的原型对象继承自构造对象的原型对象
    // 以第二次执行函数的参数,在obj作用域中执行func
    // 同理,returnObj是“对象”类型(比如new1(Object)),那么这个对象会取代newObj作为返回的对象
    function new2(func) {
      return function () {
        let newObj = {
          __proto__: func.prototype,
        };
        var returnObj = func.apply(obj, arguments);
        if (
          (typeof returnObj === "object" || typeof returnObj === "function") &&
          returnObj !== null
        ) {
          return returnObj;
        }
        return newObj;
      };
    }
    // console.log(new1("ssss"));
    // 防抖 最后一次触发算起，间隔单位事件再执行
    function debounce(fn, wait) {
      var timer = null
      return function () {
        clearTomeout(timer);
        timer = setTimeout(() => {
          fn();
        }, wait);
      };
    }

    // 节流 单位事件内只触发一次
    var flag = false
    function throttle(fn, wait) {
     if(!flag){
       console.log('现在不能执行')
       return
     }
     flag = false
      setTimeout(()=>{
       fn();
       flag = true
     }, wait)
    }
    function fn() {
      console.log("这是fn");
    }

    // 手写promise
  </script>
</html>
